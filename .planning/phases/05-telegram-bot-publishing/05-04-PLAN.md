---
phase: 05-telegram-bot-publishing
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - functions/src/publishing/photoResizer.ts
  - functions/src/publishing/common.ts
  - functions/src/publishing/types.ts
  - src/types/publishing.ts
autonomous: true
requirements:
  - PORT-08

must_haves:
  truths:
    - "System resizes photos to meet sahibinden.com requirements (800x600, max 5MB)"
    - "System resizes photos to meet hepsiemlak requirements (1024x768)"
    - "System resizes photos to meet emlakjet requirements (1024x768)"
  artifacts:
    - path: "functions/src/publishing/photoResizer.ts"
      provides: "Portal-specific image resizing using Sharp"
      exports: ["resizeForPortal", "generatePortalPhotos"]
    - path: "functions/src/publishing/common.ts"
      provides: "Shared publishing utilities"
      exports: ["getPortalSpecs", "PortalType"]
  key_links:
    - from: "functions/src/publishing/photoResizer.ts"
      to: "sharp"
      via: "image processing"
      pattern: "import sharp from.*sharp"
---

<objective>
Create photo resizing infrastructure for Turkish real estate portals with portal-specific specifications.

Purpose: Ensure property photos meet each portal's requirements before publishing, preventing upload failures and quality issues.

Output: Photo resizing functions for sahibinden.com, hepsiemlak, and emlakjet with quality optimization.
</objective>

<execution_context>
@/home/cagr/.claude/get-shit-done/workflows/execute-plan.md
@/home/cagr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-telegram-bot-publishing/05-RESEARCH.md
@functions/src/jobs/imageProcessor.ts
@functions/src/services/cloudinaryService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create portal specifications and types</name>
  <files>
    functions/src/publishing/types.ts
    functions/src/publishing/common.ts
    src/types/publishing.ts
  </files>
  <action>
1. Create functions/src/publishing/ directory

2. Create functions/src/publishing/types.ts:
   ```typescript
   export type PortalType = 'sahibinden' | 'hepsiemlak' | 'emlakjet';

   export interface PortalPhotoSpecs {
     maxWidth: number;
     maxHeight: number;
     quality: number;
     maxSizeBytes: number;
     format: 'jpeg' | 'png';
   }

   export interface PublishingResult {
     success: boolean;
     portalListingId?: string;
     portalListingUrl?: string;
     error?: string;
   }

   export interface ListingData {
     propertyId: string;
     title: string;
     description: string;
     price: number;
     currency: 'TRY' | 'USD' | 'EUR';
     propertyType: string;
     rooms?: string;
     area?: number;
     location: {
       city: string;
       district?: string;
       neighborhood?: string;
     };
     features: string[];
     photoUrls: string[];  // Firebase Storage URLs
   }
   ```

3. Create functions/src/publishing/common.ts:
   ```typescript
   import { PortalType, PortalPhotoSpecs } from './types';

   export function getPortalSpecs(portal: PortalType): PortalPhotoSpecs {
     const specs: Record<PortalType, PortalPhotoSpecs> = {
       sahibinden: {
         maxWidth: 800,
         maxHeight: 600,
         quality: 85,
         maxSizeBytes: 5 * 1024 * 1024, // 5MB
         format: 'jpeg'
       },
       hepsiemlak: {
         maxWidth: 1024,
         maxHeight: 768,
         quality: 85,
         maxSizeBytes: 5 * 1024 * 1024,
         format: 'jpeg'
       },
       emlakjet: {
         maxWidth: 1024,
         maxHeight: 768,
         quality: 85,
         maxSizeBytes: 5 * 1024 * 1024,
         format: 'jpeg'
       }
     };
     return specs[portal];
   }

   export { PortalType };
   ```

4. Create src/types/publishing.ts for client-side types:
   - Export same types for use in React components
   - Add PublishingStatus type: 'pending' | 'publishing' | 'published' | 'failed'
  </action>
  <verify>
    - functions/src/publishing/types.ts exists with all types
    - functions/src/publishing/common.ts exports getPortalSpecs
    - cd functions && npm run build compiles
  </verify>
  <done>Portal specifications and publishing types defined</done>
</task>

<task type="auto">
  <name>Task 2: Implement photo resizing for portals</name>
  <files>
    functions/src/publishing/photoResizer.ts
  </files>
  <action>
1. Create functions/src/publishing/photoResizer.ts:
   ```typescript
   import sharp from 'sharp';
   import { getPortalSpecs, PortalType } from './common';

   interface ResizedPhoto {
     buffer: Buffer;
     size: number;
     width: number;
     height: number;
   }

   /**
    * Resize a single photo for a specific portal
    * Handles quality reduction if size exceeds limit
    */
   export async function resizeForPortal(
     sourceBuffer: Buffer,
     portal: PortalType
   ): Promise<ResizedPhoto> {
     const specs = getPortalSpecs(portal);
     let quality = specs.quality;

     // Initial resize
     let buffer = await sharp(sourceBuffer)
       .resize(specs.maxWidth, specs.maxHeight, {
         fit: 'inside',
         withoutEnlargement: true
       })
       .jpeg({
         quality,
         progressive: true,
         mozjpeg: true
       })
       .toBuffer();

     // Reduce quality if still too large
     while (buffer.length > specs.maxSizeBytes && quality > 60) {
       quality -= 5;
       buffer = await sharp(sourceBuffer)
         .resize(specs.maxWidth, specs.maxHeight, {
           fit: 'inside',
           withoutEnlargement: true
         })
         .jpeg({
           quality,
           progressive: true,
           mozjpeg: true
         })
         .toBuffer();
     }

     // Get final dimensions
     const metadata = await sharp(buffer).metadata();

     return {
       buffer,
       size: buffer.length,
       width: metadata.width || specs.maxWidth,
       height: metadata.height || specs.maxHeight
     };
   }
   ```

2. Add batch processing function:
   ```typescript
   /**
    * Resize all photos for a specific portal
    * Downloads from Firebase Storage, resizes, returns buffers
    */
   export async function generatePortalPhotos(
     photoUrls: string[],
     portal: PortalType
   ): Promise<ResizedPhoto[]> {
     const results: ResizedPhoto[] = [];

     for (const url of photoUrls) {
       try {
         // Download photo
         const response = await fetch(url);
         if (!response.ok) {
           console.error(`Failed to fetch photo: ${url}`);
           continue;
         }
         const sourceBuffer = Buffer.from(await response.arrayBuffer());

         // Resize for portal
         const resized = await resizeForPortal(sourceBuffer, portal);
         results.push(resized);
       } catch (error) {
         console.error(`Error processing photo ${url}:`, error);
       }
     }

     return results;
   }
   ```

3. Add validation function:
   ```typescript
   /**
    * Validate photo meets portal requirements
    */
   export function validateForPortal(
     buffer: Buffer,
     portal: PortalType
   ): { valid: boolean; errors: string[] } {
     const specs = getPortalSpecs(portal);
     const errors: string[] = [];

     if (buffer.length > specs.maxSizeBytes) {
       errors.push(`Dosya boyutu cok buyuk: ${(buffer.length / 1024 / 1024).toFixed(2)}MB (max: ${specs.maxSizeBytes / 1024 / 1024}MB)`);
     }

     return {
       valid: errors.length === 0,
       errors
     };
   }
   ```
  </action>
  <verify>
    - cd functions && npm run build compiles
    - photoResizer.ts exports resizeForPortal, generatePortalPhotos, validateForPortal
    - Sharp import present for image processing
  </verify>
  <done>Photo resizing with quality optimization and batch processing implemented</done>
</task>

<task type="auto">
  <name>Task 3: Add photo download from Firebase Storage</name>
  <files>
    functions/src/publishing/photoResizer.ts
  </files>
  <action>
1. Enhance generatePortalPhotos to handle Firebase Storage URLs:
   ```typescript
   import { getStorage } from 'firebase-admin/storage';

   /**
    * Download photo from Firebase Storage or external URL
    */
   async function downloadPhoto(url: string): Promise<Buffer | null> {
     try {
       // Check if it's a Firebase Storage URL
       if (url.includes('firebasestorage.googleapis.com') || url.includes('storage.googleapis.com')) {
         // Extract path from URL
         const urlObj = new URL(url);
         const pathMatch = urlObj.pathname.match(/\/o\/(.+?)(\?|$)/);
         if (pathMatch) {
           const filePath = decodeURIComponent(pathMatch[1]);
           const storage = getStorage();
           const file = storage.bucket().file(filePath);
           const [buffer] = await file.download();
           return buffer;
         }
       }

       // Fall back to HTTP fetch for external URLs
       const response = await fetch(url);
       if (!response.ok) {
         console.error(`HTTP error fetching ${url}: ${response.status}`);
         return null;
       }
       return Buffer.from(await response.arrayBuffer());
     } catch (error) {
       console.error(`Error downloading photo ${url}:`, error);
       return null;
     }
   }
   ```

2. Update generatePortalPhotos to use downloadPhoto:
   - Replace direct fetch with downloadPhoto helper
   - Handle null returns (skip failed downloads)
   - Log progress for debugging

3. Add parallel processing with concurrency limit:
   ```typescript
   /**
    * Process photos in parallel with concurrency limit
    */
   async function processWithConcurrency<T, R>(
     items: T[],
     processor: (item: T) => Promise<R | null>,
     concurrency: number = 3
   ): Promise<R[]> {
     const results: R[] = [];

     for (let i = 0; i < items.length; i += concurrency) {
       const batch = items.slice(i, i + concurrency);
       const batchResults = await Promise.all(
         batch.map(item => processor(item))
       );
       results.push(...batchResults.filter((r): r is R => r !== null));
     }

     return results;
   }
   ```
  </action>
  <verify>
    - cd functions && npm run build compiles
    - Firebase Storage download handling present
    - Concurrency limit prevents overloading
  </verify>
  <done>Photo downloading from Firebase Storage with concurrency control implemented</done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `cd functions && npm run build` succeeds
2. Sharp used for image resizing with progressive JPEG
3. Portal specs match research: sahibinden 800x600, hepsiemlak/emlakjet 1024x768
4. Quality reduction loop prevents oversized photos
</verification>

<success_criteria>
- Portal specifications defined for all three Turkish portals
- Photo resizing handles dimension and file size requirements
- Quality automatically reduced if file size exceeds limit
- Firebase Storage URLs properly handled
- Batch processing with concurrency control for efficiency
</success_criteria>

<output>
After completion, create `.planning/phases/05-telegram-bot-publishing/05-04-SUMMARY.md`
</output>
