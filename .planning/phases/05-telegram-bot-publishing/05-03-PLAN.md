---
phase: 05-telegram-bot-publishing
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - functions/src/triggers/onPropertyCreated.ts
  - functions/src/triggers/onCustomerCreated.ts
  - functions/src/index.ts
  - src/types/customer.ts
autonomous: true
requirements:
  - ESLE-04
  - ESLE-05

must_haves:
  truths:
    - "New property triggers automatic notification to matching customers"
    - "New customer sees suggested matching properties immediately"
    - "Notifications are sent via in-app notification system"
  artifacts:
    - path: "functions/src/triggers/onPropertyCreated.ts"
      provides: "Firestore trigger for new property matching"
      exports: ["notifyMatchingCustomers"]
    - path: "functions/src/triggers/onCustomerCreated.ts"
      provides: "Firestore trigger for new customer suggestions"
      exports: ["suggestMatchingProperties"]
  key_links:
    - from: "functions/src/triggers/onPropertyCreated.ts"
      to: "onDocumentCreated"
      via: "firebase-functions/v2/firestore"
      pattern: "onDocumentCreated"
    - from: "functions/src/triggers/onPropertyCreated.ts"
      to: "notifications collection"
      via: "Firestore write"
      pattern: "collection.*notifications.*add"
---

<objective>
Implement Firestore triggers for automatic matching notifications when new properties or customers are created.

Purpose: Automate the matching notification workflow so agents are immediately informed of relevant matches without manual action.

Output: Two Firestore triggers that create in-app notifications for matching entities.
</objective>

<execution_context>
@/home/cagr/.claude/get-shit-done/workflows/execute-plan.md
@/home/cagr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/05-telegram-bot-publishing/05-RESEARCH.md
@.planning/phases/03-background-processing-scraping/03-04-SUMMARY.md
@functions/src/index.ts
@src/lib/matching/scoring-engine.ts
@src/types/notification.ts
@src/types/customer.ts
@src/types/property.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create onPropertyCreated trigger for customer notifications</name>
  <files>
    functions/src/triggers/onPropertyCreated.ts
  </files>
  <action>
1. Create functions/src/triggers/ directory if not exists

2. Create functions/src/triggers/onPropertyCreated.ts:
   - Import onDocumentCreated from firebase-functions/v2/firestore
   - Import getFirestore from firebase-admin/firestore
   - Use region "europe-west1" for KVKK compliance

3. Implement trigger logic:
   ```typescript
   export const notifyMatchingCustomers = onDocumentCreated(
     {
       document: "users/{userId}/properties/{propertyId}",
       region: "europe-west1"
     },
     async (event) => {
       // Idempotency check
       const property = event.data?.data();
       if (!property || property.matchNotificationsSent) {
         return;
       }

       const userId = event.params.userId;
       const propertyId = event.params.propertyId;

       // Get all customers for this user
       const db = getFirestore();
       const customersSnap = await db
         .collection("users").doc(userId)
         .collection("customers")
         .get();

       // Score each customer against this property
       const matches = [];
       for (const doc of customersSnap.docs) {
         const customer = doc.data();
         const score = scorePropertyForCustomer(customer, property);
         if (score >= 60) { // 60% threshold
           matches.push({ customer, customerId: doc.id, score });
         }
       }

       // Create notifications for top 5 matches
       for (const match of matches.slice(0, 5)) {
         await db.collection("users").doc(userId)
           .collection("notifications").add({
             type: "property_match",
             title: `Yeni mulk: ${property.title}`,
             message: `${match.customer.name} icin %${match.score} eslesen mulk eklendi`,
             data: {
               propertyId,
               customerId: match.customerId,
               score: match.score
             },
             read: false,
             createdAt: new Date()
           });
       }

       // Mark as processed (idempotency)
       await event.data?.ref.update({ matchNotificationsSent: true });
     }
   );
   ```

4. Implement simplified scoring function (duplicated from client for functions isolation):
   - Location match: 30 points if customer.preferences.location includes property.location.city or district
   - Budget match: 30 points if property.price is within customer.preferences.budget range
   - Type match: 20 points if customer.preferences.propertyType includes property.type
   - Rooms match: 20 points if customer.preferences.rooms includes property.rooms
   - Return total score (0-100)
  </action>
  <verify>
    - cd functions && npm run build compiles
    - onPropertyCreated.ts exports notifyMatchingCustomers
    - Trigger uses "users/{userId}/properties/{propertyId}" document path
  </verify>
  <done>New property creation triggers matching customer notifications</done>
</task>

<task type="auto">
  <name>Task 2: Create onCustomerCreated trigger for property suggestions</name>
  <files>
    functions/src/triggers/onCustomerCreated.ts
  </files>
  <action>
1. Create functions/src/triggers/onCustomerCreated.ts:
   - Same pattern as onPropertyCreated but reversed logic
   - Trigger on "users/{userId}/customers/{customerId}"
   - Use region "europe-west1"

2. Implement trigger logic:
   ```typescript
   export const suggestMatchingProperties = onDocumentCreated(
     {
       document: "users/{userId}/customers/{customerId}",
       region: "europe-west1"
     },
     async (event) => {
       const customer = event.data?.data();
       if (!customer || customer.suggestionsSent) {
         return;
       }

       const userId = event.params.userId;
       const customerId = event.params.customerId;

       // Get all active properties for this user
       const db = getFirestore();
       const propertiesSnap = await db
         .collection("users").doc(userId)
         .collection("properties")
         .where("status", "==", "aktif")
         .get();

       // Score each property against this customer
       const matches = [];
       for (const doc of propertiesSnap.docs) {
         const property = doc.data();
         const score = scorePropertyForCustomer(customer, property);
         if (score >= 60) {
           matches.push({ property, propertyId: doc.id, score });
         }
       }

       // Create single notification with all suggestions
       if (matches.length > 0) {
         const topMatches = matches
           .sort((a, b) => b.score - a.score)
           .slice(0, 5);

         await db.collection("users").doc(userId)
           .collection("notifications").add({
             type: "customer_suggestions",
             title: `${customer.name} icin ${topMatches.length} mulk onerisi`,
             message: topMatches.map(m =>
               `${m.property.title} (%${m.score})`
             ).join(", "),
             data: {
               customerId,
               suggestions: topMatches.map(m => ({
                 propertyId: m.propertyId,
                 score: m.score
               }))
             },
             read: false,
             createdAt: new Date()
           });
       }

       // Mark as processed
       await event.data?.ref.update({ suggestionsSent: true });
     }
   );
   ```

3. Reuse scoring function from Task 1 (import or duplicate)
  </action>
  <verify>
    - cd functions && npm run build compiles
    - onCustomerCreated.ts exports suggestMatchingProperties
    - Trigger uses "users/{userId}/customers/{customerId}" document path
  </verify>
  <done>New customer creation triggers property suggestion notifications</done>
</task>

<task type="auto">
  <name>Task 3: Export triggers and add telegramChatId field</name>
  <files>
    functions/src/index.ts
    src/types/customer.ts
  </files>
  <action>
1. Update functions/src/index.ts:
   - Add exports for both triggers:
     ```typescript
     export { notifyMatchingCustomers } from './triggers/onPropertyCreated';
     export { suggestMatchingProperties } from './triggers/onCustomerCreated';
     ```

2. Update src/types/customer.ts:
   - Add optional telegramChatId field to Customer interface:
     ```typescript
     telegramChatId?: number;  // Telegram chat ID for notifications
     ```
   - This field will be populated when user links their Telegram account

3. Verify all exports in index.ts are correct:
   - Existing: processPropertyPhoto, enhancePropertyPhoto, importPropertyFromUrl, processPropertyImport, monitorCompetitors, transcribeVoice
   - New: notifyMatchingCustomers, suggestMatchingProperties
  </action>
  <verify>
    - cd functions && npm run build compiles
    - index.ts exports both trigger functions
    - Customer type includes telegramChatId field
  </verify>
  <done>All triggers exported and Customer type updated for Telegram integration</done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `cd functions && npm run build` succeeds
2. Triggers exported from index.ts
3. Idempotency checks in both triggers (matchNotificationsSent, suggestionsSent flags)
4. Scoring logic matches existing pattern from scoring-engine.ts
</verification>

<success_criteria>
- notifyMatchingCustomers trigger fires on new property creation
- suggestMatchingProperties trigger fires on new customer creation
- Both triggers create in-app notifications with matching scores
- Idempotency flags prevent duplicate notifications
- Customer type includes telegramChatId for future Telegram notifications
</success_criteria>

<output>
After completion, create `.planning/phases/05-telegram-bot-publishing/05-03-SUMMARY.md`
</output>
