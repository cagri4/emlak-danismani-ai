---
phase: 03-background-processing-scraping
plan: 04
type: execute
wave: 2
depends_on: ["03-03"]
files_modified:
  - functions/src/schedulers/competitorMonitor.ts
  - functions/src/index.ts
  - src/types/notification.ts
  - src/lib/firebase/notification-service.ts
  - src/hooks/useNotifications.ts
  - src/components/notifications/NotificationBell.tsx
  - src/components/notifications/NotificationDropdown.tsx
  - src/components/layout/Header.tsx
  - src/pages/settings/MonitoringSettingsPage.tsx
autonomous: true
requirements:
  - PORT-09
  - PORT-10

must_haves:
  truths:
    - "System checks competitor listings twice daily (9 AM and 9 PM Turkey time)"
    - "User can configure monitoring criteria (region, price range) in settings"
    - "System also monitors based on existing customer preferences"
    - "New matches appear in notification bell on dashboard"
    - "User can view details and one-click import from notification"
  artifacts:
    - path: "functions/src/schedulers/competitorMonitor.ts"
      provides: "Scheduled function for competitor monitoring"
      contains: "onSchedule"
    - path: "src/components/notifications/NotificationBell.tsx"
      provides: "Notification bell with unread count"
    - path: "src/components/notifications/NotificationDropdown.tsx"
      provides: "Dropdown showing notifications with import action"
    - path: "src/hooks/useNotifications.ts"
      provides: "Real-time notification subscription"
      exports: ["useNotifications"]
    - path: "src/pages/settings/MonitoringSettingsPage.tsx"
      provides: "UI for configuring monitoring criteria"
  key_links:
    - from: "functions/src/schedulers/competitorMonitor.ts"
      to: "functions/src/scrapers/*"
      via: "portal scraping"
      pattern: "scrapeSahibinden|scrapeHepsiemlak|scrapeEmlakjet"
    - from: "src/components/notifications/NotificationDropdown.tsx"
      to: "src/lib/ai/command-handlers.ts"
      via: "one-click import"
      pattern: "handleImport"
---

<objective>
Build competitor monitoring system with scheduled scraping and in-app notifications.

Purpose: Automatically track competitor listings based on user-defined criteria and customer preferences. Notify user of new relevant properties via notification bell on dashboard, enabling quick import.

Output: Scheduled monitoring function, notification system, monitoring settings page.
</objective>

<execution_context>
@/home/cagr/.claude/get-shit-done/workflows/execute-plan.md
@/home/cagr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-background-processing-scraping/03-RESEARCH.md
@.planning/phases/03-background-processing-scraping/03-CONTEXT.md
@.planning/phases/03-background-processing-scraping/03-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create scheduled competitor monitoring function</name>
  <files>
    functions/src/schedulers/competitorMonitor.ts
    functions/src/index.ts
  </files>
  <action>
Create scheduled Cloud Function for competitor monitoring:

1. Create functions/src/schedulers/competitorMonitor.ts:

   Import onSchedule from firebase-functions/v2/scheduler

   Function: monitorCompetitors (per RESEARCH.md Pattern 2)
   - Schedule: '0 9,21 * * *' (9 AM and 9 PM per user decision)
   - TimeZone: 'Europe/Istanbul' (per user decision)
   - Region: europe-west1

   Logic:
   a) Fetch all users with active monitoring criteria:
      - users/{userId}/monitoring_criteria collection
      - Each doc: { region, priceMin, priceMax, propertyType, portals: string[], enabled: boolean }

   b) Fetch customer preferences for each user:
      - users/{userId}/customers with preferences
      - Extract unique location/budget/type combinations

   c) For each portal in user's config:
      - Build search URL based on criteria
      - Scrape search results page (not detail page)
      - Extract listing URLs and basic info

   d) Compare with existing properties:
      - Use sourceId to detect already-seen listings
      - Skip if already in user's properties

   e) For new listings:
      - Create notification in users/{userId}/notifications
      - Include: listing URL, title, price, location, portal, timestamp, read: false

   Search URL patterns (best-effort, may need adjustment):
   - sahibinden: /satilik-daire/DISTRICT?pagingSize=20&price_min=X&price_max=Y
   - hepsiemlak: /satilik/DISTRICT?fiyat_min=X&fiyat_max=Y
   - emlakjet: /satilik/DISTRICT/fiyat-X-Y

   Per user decision: "Track both: manual region+price criteria AND properties matching customer preferences"

   Error handling:
   - Catch per-user errors, continue with other users
   - Log failed scrapes but don't fail entire function
   - Rate limit between portal requests (2-3 second delay)

2. Update functions/src/index.ts:
   - Export monitorCompetitors from schedulers/competitorMonitor
  </action>
  <verify>
    - competitorMonitor.ts compiles without errors
    - Schedule syntax valid for 9 AM and 9 PM
    - TimeZone set to Europe/Istanbul
    - Function exported from index.ts
  </verify>
  <done>Scheduled competitor monitoring function ready to run twice daily</done>
</task>

<task type="auto">
  <name>Task 2: Create notification types and service</name>
  <files>
    src/types/notification.ts
    src/lib/firebase/notification-service.ts
    src/hooks/useNotifications.ts
  </files>
  <action>
Create notification infrastructure:

1. Create src/types/notification.ts:
   ```typescript
   export interface Notification {
     id: string;
     type: 'competitor_listing' | 'match_found' | 'system';
     title: string;
     message: string;
     read: boolean;
     createdAt: Date;
     data?: {
       listingUrl?: string;
       portal?: string;
       price?: number;
       location?: string;
       propertyId?: string;
       customerId?: string;
     };
   }

   export interface MonitoringCriteria {
     id: string;
     region: string;
     priceMin?: number;
     priceMax?: number;
     propertyType?: string;
     portals: ('sahibinden' | 'hepsiemlak' | 'emlakjet')[];
     enabled: boolean;
   }
   ```

2. Create src/lib/firebase/notification-service.ts:
   - Uses Firestore path: users/{userId}/notifications

   Functions:
   - getNotifications(userId: string): Promise<Notification[]>
     - Order by createdAt desc
     - Limit 50 most recent

   - markAsRead(userId: string, notificationId: string): Promise<void>
     - Update read: true

   - markAllAsRead(userId: string): Promise<void>
     - Batch update all unread to read: true

   - deleteNotification(userId: string, notificationId: string): Promise<void>

   - subscribeToNotifications(userId: string, callback: (notifications: Notification[]) => void)
     - Real-time listener with onSnapshot
     - Return unsubscribe function

   - getUnreadCount(userId: string): Promise<number>
     - Count where read == false

3. Create src/hooks/useNotifications.ts:
   - Import notification-service
   - Import useAuth for userId

   Hook: useNotifications()
   Returns:
   - notifications: Notification[]
   - unreadCount: number
   - isLoading: boolean
   - markAsRead: (id: string) => void
   - markAllAsRead: () => void
   - deleteNotification: (id: string) => void

   Real-time subscription:
   - Subscribe on mount
   - Unsubscribe on unmount
   - Track unread count
  </action>
  <verify>
    - Types export correctly
    - notification-service compiles
    - useNotifications hook returns correct shape
    - Real-time subscription pattern correct
  </verify>
  <done>Notification service and hook ready for UI integration</done>
</task>

<task type="auto">
  <name>Task 3: Create notification UI and monitoring settings</name>
  <files>
    src/components/notifications/NotificationBell.tsx
    src/components/notifications/NotificationDropdown.tsx
    src/components/layout/Header.tsx
    src/pages/settings/MonitoringSettingsPage.tsx
  </files>
  <action>
Create notification UI components and monitoring settings:

1. Create src/components/notifications/NotificationBell.tsx:
   - Import useNotifications hook
   - Props: { onClick: () => void }

   Per user decision: "In-app notification bell on dashboard"

   UI:
   - Bell icon (lucide-react Bell)
   - Badge with unread count (if > 0)
   - Badge shows "9+" if count > 9
   - Animate badge on new notification (optional)

   Per RESEARCH.md code example for badge.

2. Create src/components/notifications/NotificationDropdown.tsx:
   - Props: { notifications: Notification[], onMarkAsRead, onImport, onClose }

   UI:
   - Header: "Bildirimler" + "Tümünü okundu işaretle" button
   - Scrollable list (max-height)
   - Each notification card:
     - Portal badge (sahibinden/hepsiemlak/emlakjet)
     - Title, location, price
     - Time ago (date-fns formatDistanceToNow)
     - Unread indicator (blue dot)
     - Actions: "Detay" (open URL), "İçe Aktar" (one-click import)

   Per user decision: "Actions: View details + one-click import"

   One-click import:
   - Call importPropertyFromUrl with listing URL
   - Show success/error toast
   - Mark notification as read

   Empty state: "Yeni bildirim yok"

3. Update src/components/layout/Header.tsx:
   - Add NotificationBell before user menu (after upload indicator)
   - Toggle NotificationDropdown on bell click
   - Close dropdown on outside click

4. Create src/pages/settings/MonitoringSettingsPage.tsx:
   - Path: /ayarlar/izleme or integrate into existing settings

   UI sections:

   a) Manual Criteria:
      - Add new criteria form:
        - Region dropdown (cities)
        - Price range (min/max inputs)
        - Property type dropdown
        - Portals checkboxes (sahibinden, hepsiemlak, emlakjet)
      - List existing criteria with edit/delete
      - Enable/disable toggle per criteria

   b) Customer-based monitoring:
      - Explanation: "Müşteri tercihlerine göre otomatik izlenir"
      - Link to customer list
      - Info: Shows count of active customers being monitored

   c) Schedule info:
      - Display: "Günde 2 kez kontrol edilir (09:00 ve 21:00)"
      - Note: Can't change schedule (per user decision)

   Firestore:
   - Save criteria to users/{userId}/monitoring_criteria
   - Use useForm for validation
  </action>
  <verify>
    - NotificationBell shows unread count
    - NotificationDropdown lists notifications
    - One-click import triggers import flow
    - MonitoringSettingsPage allows adding/editing criteria
    - npm run build succeeds
  </verify>
  <done>Notification UI and monitoring settings complete</done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds
2. Scheduled function configured for 9 AM and 9 PM Istanbul time
3. Notification bell shows in header with unread count
4. Dropdown shows notification list with import action
5. Settings page allows configuring monitoring criteria
6. All Turkish text in UI
</verification>

<success_criteria>
- Cloud Function scheduled for twice daily execution
- Monitors based on user criteria AND customer preferences
- New competitor listings create notifications
- Notification bell shows unread count on dashboard
- Dropdown shows notification details
- One-click import works from notification
- User can configure monitoring criteria in settings
- Notification marked as read after interaction
</success_criteria>

<output>
After completion, create `.planning/phases/03-background-processing-scraping/03-04-SUMMARY.md`
</output>
