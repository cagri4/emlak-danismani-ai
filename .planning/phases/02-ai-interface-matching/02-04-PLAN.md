---
phase: 02-ai-interface-matching
plan: 04
type: execute
wave: 2
depends_on:
  - "02-01"
files_modified:
  - src/lib/matching/scoring-engine.ts
  - src/lib/matching/feedback-tracker.ts
  - src/lib/matching/explanation-generator.ts
  - src/hooks/useMatching.ts
  - src/types/matching.ts
  - src/components/chat/MatchResults.tsx
autonomous: true
requirements:
  - ESLE-01
  - ESLE-02
  - ESLE-03

must_haves:
  truths:
    - "User can say 'Mehmet i√ßin m√ºlk bul' and see matching properties"
    - "System scores matches based on location, budget, type"
    - "Match results show percentage score"
    - "Match results include natural language explanation"
    - "Top 5 matches shown by default"
    - "Both directions work: properties for customer, customers for property"
  artifacts:
    - path: "src/lib/matching/scoring-engine.ts"
      provides: "Multi-factor scoring algorithm"
      exports: ["scoreMatch", "findMatchesForCustomer", "findMatchesForProperty"]
    - path: "src/lib/matching/explanation-generator.ts"
      provides: "Natural language match explanations"
      exports: ["generateExplanation"]
    - path: "src/hooks/useMatching.ts"
      provides: "Matching hook for components"
      exports: ["useMatching"]
  key_links:
    - from: "src/lib/matching/scoring-engine.ts"
      to: "src/hooks/useProperties.ts"
      via: "fetches properties for matching"
      pattern: "getProperties|properties"
    - from: "src/lib/matching/scoring-engine.ts"
      to: "src/hooks/useCustomers.ts"
      via: "fetches customers for matching"
      pattern: "getCustomers|customers"
    - from: "src/lib/matching/explanation-generator.ts"
      to: "claude"
      via: "generates natural language"
      pattern: "streamMessage|createMessage"
---

<objective>
Create property-customer matching engine with weighted scoring, feedback learning, and natural language explanations. Users can request matches via chat and see ranked results with explanations.

Purpose: Intelligent matching is a key value prop - helping agents quickly find relevant properties for customers and vice versa.
Output: Scoring engine, explanation generator, match results component.
</objective>

<execution_context>
@/home/cagr/.claude/get-shit-done/workflows/execute-plan.md
@/home/cagr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-ai-interface-matching/02-RESEARCH.md
@.planning/phases/02-ai-interface-matching/02-CONTEXT.md

# From Plan 01 - customer types and hooks
@src/types/customer.ts
@src/hooks/useCustomers.ts

# From Phase 1 - property types and hooks
@src/types/property.ts
@src/hooks/useProperties.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Matching Types and Scoring Engine</name>
  <files>
    src/types/matching.ts
    src/lib/matching/scoring-engine.ts
  </files>
  <action>
**src/types/matching.ts:**
```typescript
export interface MatchScore {
  score: number;  // 0-100
  factors: {
    locationMatch: number;   // 0-30 points
    budgetMatch: number;     // 0-30 points
    typeMatch: number;       // 0-20 points
    roomsMatch: number;      // 0-20 points
    historyPenalty: number;  // negative points for past rejections
  };
}

export interface PropertyMatch {
  property: Property;
  score: MatchScore;
  explanation: string;
}

export interface CustomerMatch {
  customer: Customer;
  score: MatchScore;
  explanation: string;
}

export interface MatchOutcome {
  id: string;
  customerId: string;
  propertyId: string;
  shown: boolean;      // Was property shown to customer?
  liked: boolean;      // Did customer like it?
  reason?: string;     // Why liked/rejected
  timestamp: Date;
}
```

**src/lib/matching/scoring-engine.ts:**
Implement weighted scoring per research:

```typescript
export async function scorePropertyForCustomer(
  customer: Customer,
  property: Property,
  outcomes: MatchOutcome[]
): Promise<MatchScore> {
  const factors = {
    locationMatch: 0,
    budgetMatch: 0,
    typeMatch: 0,
    roomsMatch: 0,
    historyPenalty: 0
  };

  // Location (30% weight)
  if (customer.preferences.location.includes(property.location.city)) {
    factors.locationMatch = 30;
  } else if (customer.preferences.location.some(loc =>
    property.location.district?.toLowerCase().includes(loc.toLowerCase())
  )) {
    factors.locationMatch = 20;  // Partial match
  }

  // Budget (30% weight)
  const { min, max } = customer.preferences.budget;
  if (property.price >= min && property.price <= max) {
    factors.budgetMatch = 30;
  } else if (property.price >= min * 0.9 && property.price <= max * 1.1) {
    factors.budgetMatch = 15;  // Within 10% tolerance
  }

  // Property type (20% weight)
  if (customer.preferences.propertyType.includes(property.type)) {
    factors.typeMatch = 20;
  }

  // Rooms (20% weight)
  if (customer.preferences.rooms?.includes(property.rooms)) {
    factors.roomsMatch = 20;
  } else if (!customer.preferences.rooms || customer.preferences.rooms.length === 0) {
    factors.roomsMatch = 10;  // No preference = partial match
  }

  // History penalty - check past rejections
  const rejections = outcomes.filter(o =>
    !o.liked &&
    o.customerId === customer.id
  );
  const similarRejections = rejections.filter(o =>
    // Check if rejected property was similar
    // (implementation depends on stored property data)
    true  // Simplified for now
  );
  factors.historyPenalty = Math.max(-20, -5 * similarRejections.length);

  const score = Object.values(factors).reduce((sum, val) => sum + val, 0);

  return {
    score: Math.max(0, Math.min(100, score)),
    factors
  };
}

export async function findMatchesForCustomer(
  customer: Customer,
  properties: Property[],
  outcomes: MatchOutcome[],
  limit = 5
): Promise<PropertyMatch[]> {
  const matches = await Promise.all(
    properties
      .filter(p => p.status === 'aktif')  // Only active properties
      .map(async (property) => ({
        property,
        score: await scorePropertyForCustomer(customer, property, outcomes),
        explanation: ''  // Filled later
      }))
  );

  // Sort by score descending
  matches.sort((a, b) => b.score.score - a.score.score);

  // Take top N
  return matches.slice(0, limit);
}

// Reverse matching: find customers for a property
export async function findMatchesForProperty(
  property: Property,
  customers: Customer[],
  outcomes: MatchOutcome[],
  limit = 5
): Promise<CustomerMatch[]> {
  // Similar logic, reversed
}
```
  </action>
  <verify>
- TypeScript compiles
- scorePropertyForCustomer returns valid MatchScore
- findMatchesForCustomer returns sorted array
  </verify>
  <done>
- Matching types defined
- Scoring engine implements weighted algorithm
- Both directions (property for customer, customer for property) supported
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Feedback Tracker and Explanation Generator</name>
  <files>
    src/lib/matching/feedback-tracker.ts
    src/lib/matching/explanation-generator.ts
  </files>
  <action>
**src/lib/matching/feedback-tracker.ts:**
Track match outcomes for learning:

```typescript
export async function recordMatchOutcome(
  userId: string,
  customerId: string,
  propertyId: string,
  outcome: { shown: boolean; liked: boolean; reason?: string }
): Promise<void> {
  // Store in Firestore: users/{userId}/match_outcomes
  const outcomeRef = collection(db, `users/${userId}/match_outcomes`);
  await addDoc(outcomeRef, {
    customerId,
    propertyId,
    ...outcome,
    timestamp: serverTimestamp()
  });
}

export async function getOutcomesForCustomer(
  userId: string,
  customerId: string
): Promise<MatchOutcome[]> {
  const q = query(
    collection(db, `users/${userId}/match_outcomes`),
    where('customerId', '==', customerId),
    orderBy('timestamp', 'desc'),
    limit(50)
  );
  const snapshot = await getDocs(q);
  return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
}
```

**src/lib/matching/explanation-generator.ts:**
Generate natural language explanations (per user decision: conversational, not bullet points):

```typescript
export async function generateExplanation(
  customer: Customer,
  property: Property,
  score: MatchScore
): Promise<string> {
  // For high scores, use template-based for speed
  if (score.score >= 80) {
    return generateHighMatchExplanation(customer, property, score);
  }

  // For lower scores, explain what's missing
  return generatePartialMatchExplanation(customer, property, score);
}

function generateHighMatchExplanation(
  customer: Customer,
  property: Property,
  score: MatchScore
): string {
  const parts: string[] = [];

  if (score.factors.locationMatch >= 25) {
    parts.push(`${property.location.city} tam istediƒüi b√∂lgede`);
  }

  if (score.factors.budgetMatch >= 25) {
    parts.push('b√ºt√ßesine uygun');
  }

  if (score.factors.typeMatch >= 15) {
    parts.push(`${property.type} arƒ±yordu`);
  }

  if (score.factors.roomsMatch >= 15) {
    parts.push(`${property.rooms} istemi≈üti`);
  }

  return parts.join(', ') + '.';
}

function generatePartialMatchExplanation(
  customer: Customer,
  property: Property,
  score: MatchScore
): string {
  const pros: string[] = [];
  const cons: string[] = [];

  if (score.factors.locationMatch >= 20) {
    pros.push('Konum uyuyor');
  } else {
    cons.push(`${customer.preferences.location.join(' veya ')} istiyor ama bu ${property.location.city}'da`);
  }

  if (score.factors.budgetMatch >= 20) {
    pros.push('b√ºt√ßesine uygun');
  } else {
    const { min, max } = customer.preferences.budget;
    cons.push(`${formatPrice(min)}-${formatPrice(max)} arƒ±yor ama bu ${formatPrice(property.price)}`);
  }

  // Construct explanation
  let explanation = '';
  if (pros.length > 0) {
    explanation += pros.join(', ');
  }
  if (cons.length > 0) {
    explanation += (pros.length > 0 ? ', ama ' : '') + cons.join(', ');
  }

  return explanation + '.';
}
```

For no matches, per user decision:
```typescript
export function generateNoMatchExplanation(
  customer: Customer,
  properties: Property[]
): string {
  // Analyze why no matches
  const budgetTooLow = properties.every(p =>
    p.price > customer.preferences.budget.max
  );

  if (budgetTooLow) {
    return `Bu fiyat aralƒ±ƒüƒ±nda (${formatPrice(customer.preferences.budget.min)}-${formatPrice(customer.preferences.budget.max)}) uygun m√ºlk bulunamadƒ±. B√ºt√ßeyi artƒ±rƒ±rsan daha √ßok se√ßenek g√∂rebilirsin.`;
  }

  return `≈ûu anda ${customer.preferences.location.join(' veya ')} b√∂lgesinde ${customer.preferences.propertyType.join('/')} bulunamadƒ±. Yeni m√ºlkler eklendik√ße sana bildiririm.`;
}
```
  </action>
  <verify>
- recordMatchOutcome stores in Firestore
- generateExplanation returns Turkish sentence
- Explanations are conversational (not bullet points)
  </verify>
  <done>
- Feedback tracking implemented
- Natural language explanations generated
- No-match explanations provide actionable suggestions
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Matching Hook and Results Component</name>
  <files>
    src/hooks/useMatching.ts
    src/components/chat/MatchResults.tsx
  </files>
  <action>
**src/hooks/useMatching.ts:**
Hook for components to request matches:

```typescript
export function useMatching() {
  const { user } = useAuth();
  const { properties } = useProperties();
  const { customers } = useCustomers();
  const [isLoading, setIsLoading] = useState(false);

  const findPropertiesForCustomer = async (
    customerId: string,
    limit = 5
  ): Promise<PropertyMatch[]> => {
    setIsLoading(true);
    try {
      const customer = customers.find(c => c.id === customerId);
      if (!customer) throw new Error('M√º≈üteri bulunamadƒ±');

      const outcomes = await getOutcomesForCustomer(user.uid, customerId);
      const matches = await findMatchesForCustomer(
        customer,
        properties,
        outcomes,
        limit
      );

      // Generate explanations for matches
      for (const match of matches) {
        match.explanation = await generateExplanation(
          customer,
          match.property,
          match.score
        );
      }

      return matches;
    } finally {
      setIsLoading(false);
    }
  };

  const findCustomersForProperty = async (
    propertyId: string,
    limit = 5
  ): Promise<CustomerMatch[]> => {
    // Similar implementation
  };

  const recordOutcome = async (
    customerId: string,
    propertyId: string,
    liked: boolean,
    reason?: string
  ) => {
    await recordMatchOutcome(user.uid, customerId, propertyId, {
      shown: true,
      liked,
      reason
    });
  };

  return {
    findPropertiesForCustomer,
    findCustomersForProperty,
    recordOutcome,
    isLoading
  };
}
```

**src/components/chat/MatchResults.tsx:**
Display match results in chat (per user decisions):

```typescript
interface MatchResultsProps {
  matches: PropertyMatch[];
  customerName: string;
  onView: (propertyId: string) => void;
  onShare: (propertyId: string) => void;
  onFeedback: (propertyId: string, liked: boolean) => void;
}

export function MatchResults({
  matches,
  customerName,
  onView,
  onShare,
  onFeedback
}: MatchResultsProps) {
  if (matches.length === 0) {
    return (
      <div className="p-3 bg-gray-50 rounded-lg">
        <p className="text-gray-600">
          {customerName} i√ßin uygun m√ºlk bulunamadƒ±.
        </p>
      </div>
    );
  }

  return (
    <div className="space-y-3">
      <p className="text-sm text-gray-600">
        {customerName} i√ßin {matches.length} m√ºlk buldum:
      </p>
      {matches.map((match, index) => (
        <div
          key={match.property.id}
          className="p-3 bg-white border rounded-lg shadow-sm"
        >
          <div className="flex justify-between items-start">
            <div>
              <span className="font-medium">
                {index + 1}. {match.property.title}
              </span>
              <span className="ml-2 text-sm font-bold text-blue-600">
                ({match.score.score}%)
              </span>
            </div>
            <div className="flex gap-1">
              <Button size="sm" variant="ghost" onClick={() => onView(match.property.id)}>
                G√∂r√ºnt√ºle
              </Button>
              <Button size="sm" variant="ghost" onClick={() => onShare(match.property.id)}>
                Payla≈ü
              </Button>
            </div>
          </div>
          <p className="text-sm text-gray-600 mt-1">
            {match.explanation}
          </p>
          <div className="flex gap-2 mt-2">
            <Button
              size="sm"
              variant="outline"
              onClick={() => onFeedback(match.property.id, true)}
            >
              üëç Beƒüendi
            </Button>
            <Button
              size="sm"
              variant="outline"
              onClick={() => onFeedback(match.property.id, false)}
            >
              üëé Beƒüenmedi
            </Button>
          </div>
        </div>
      ))}
    </div>
  );
}
```

Per user decision: ranked list with scores, natural language explanation, view and share buttons, feedback buttons.
  </action>
  <verify>
- useMatching returns matches
- MatchResults renders all matches
- Clicking View opens property detail
- Clicking feedback records outcome
  </verify>
  <done>
- Matching hook provides all functions
- Results component shows ranked list with scores
- Explanations are conversational
- Feedback buttons record outcomes
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. `npm run build` succeeds
2. In chat: "Mehmet i√ßin m√ºlk bul"
3. See ranked list: "1. Villa Bodrum (92%) 2. Daire Ankara (78%)"
4. Each has explanation like "B√ºt√ßesine ve konumuna uyuyor, ama 2+1 istiyor bu 1+1"
5. Click "G√∂r√ºnt√ºle" - opens property detail
6. Click "Beƒüendi" - outcome recorded
7. Run same query again - score may change based on feedback
8. "Bu m√ºlk i√ßin m√º≈üteri bul" - reverse matching works
</verification>

<success_criteria>
- User can request matches for customer (ESLE-01)
- Scoring uses location, budget, type criteria (ESLE-02)
- Results show percentage and natural language reasons (ESLE-03)
- Top 5 shown by default (user decision)
- Bidirectional matching works (user decision)
- Feedback tracking implemented (user decision)
- No-match case explains why (user decision)
</success_criteria>

<output>
After completion, create `.planning/phases/02-ai-interface-matching/02-04-SUMMARY.md`
</output>
