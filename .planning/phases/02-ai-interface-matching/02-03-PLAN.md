---
phase: 02-ai-interface-matching
plan: 03
type: execute
wave: 2
depends_on:
  - "02-01"
  - "02-02"
files_modified:
  - src/lib/ai/claude-client.ts
  - src/lib/ai/command-parser.ts
  - src/lib/ai/structured-schemas.ts
  - src/lib/ai/conversation-context.ts
  - src/lib/ai/command-handlers.ts
  - src/hooks/useChat.ts
  - src/components/chat/ChatMessages.tsx
  - src/components/chat/InlinePropertyCard.tsx
  - src/components/chat/InlineCustomerCard.tsx
  - src/lib/firebase/conversation-service.ts
autonomous: true
requirements:
  - AIUI-01
  - AIUI-02
  - AIUI-03
  - AIUI-04
  - AIUI-05
  - AIUI-06
  - AIUI-08

must_haves:
  truths:
    - "User can type '3+1 daire Ankara Çankaya 2M TL' and AI parses it correctly"
    - "User can type 'Mehmet adında müşteri ekle' and AI creates customer"
    - "User can type 'Bodrum'da villa ara' and see search results"
    - "User can type 'Çankaya daireyi satıldı yap' and status updates"
    - "AI asks for confirmation before creating/modifying data"
    - "AI asks clarifying questions when ambiguous"
    - "Conversation context maintained across messages"
    - "User can edit property descriptions via chat"
  artifacts:
    - path: "src/lib/ai/claude-client.ts"
      provides: "Claude API wrapper with streaming and caching"
      contains: "cache_control"
    - path: "src/lib/ai/command-parser.ts"
      provides: "Intent detection and entity extraction"
      exports: ["parseCommand"]
    - path: "src/lib/ai/structured-schemas.ts"
      provides: "JSON schemas for structured outputs"
      contains: "intentSchema"
    - path: "src/lib/ai/command-handlers.ts"
      provides: "Execute parsed commands"
      exports: ["handleCommand"]
  key_links:
    - from: "src/hooks/useChat.ts"
      to: "src/lib/ai/claude-client.ts"
      via: "streaming API call"
      pattern: "streamMessage|createMessage"
    - from: "src/lib/ai/command-parser.ts"
      to: "src/lib/ai/structured-schemas.ts"
      via: "schema validation"
      pattern: "intentSchema"
    - from: "src/lib/ai/command-handlers.ts"
      to: "src/hooks/useProperties.ts"
      via: "property mutations"
      pattern: "addProperty|updateProperty"
---

<objective>
Wire chat UI to Claude API with Turkish natural language understanding, command parsing via structured outputs, and command execution with confirmation flows.

Purpose: This is the AI brain that makes the chat interface intelligent. Users can add properties, customers, search, and update status using natural Turkish language.
Output: Complete AI command pipeline from user input to data mutations.
</objective>

<execution_context>
@/home/cagr/.claude/get-shit-done/workflows/execute-plan.md
@/home/cagr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-ai-interface-matching/02-RESEARCH.md
@.planning/phases/02-ai-interface-matching/02-CONTEXT.md

# From Phase 1 - existing Claude integration
@src/lib/claude.ts

# From Plan 01 - customer types
@src/types/customer.ts
@src/hooks/useCustomers.ts

# From Plan 02 - chat UI
@src/hooks/useChat.ts
@src/types/chat.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Claude Client with Streaming and Prompt Caching</name>
  <files>
    src/lib/ai/claude-client.ts
    src/lib/ai/structured-schemas.ts
    src/lib/ai/conversation-context.ts
  </files>
  <action>
**src/lib/ai/claude-client.ts:**
Create Claude API client following research patterns:
- Use @anthropic-ai/sdk
- Model: claude-sonnet-4-6
- Streaming support for real-time responses
- Prompt caching with cache_control: ephemeral on system prompt

Turkish system prompt (2000+ tokens for caching):
```
Sen bir emlak danışmanı AI asistanısın. Türkçe konuşuyorsun ve emlakçılara mülk yönetimi, müşteri takibi ve eşleştirme konularında yardım ediyorsun.

Yeteneklerin:
1. Mülk ekleme: "3+1 daire Ankara Çankaya 2M TL" → mülk bilgilerini çıkar
2. Müşteri ekleme: "Mehmet adında müşteri ekle" → müşteri oluştur
3. Mülk arama: "Bodrum'da villa ara", "10-20M arası daireler" → sorgu oluştur
4. Durum güncelleme: "Çankaya daireyi satıldı yap" → durumu değiştir
5. Eşleştirme: "Mehmet için mülk bul" → uygun mülkleri bul
6. İlan düzenleme: "İlanı daha çekici yap" → metni yeniden yaz

Kurallar:
1. Her zaman Türkçe yanıt ver
2. Veri eklemeden/değiştirmeden önce MUTLAKA onay iste
3. Belirsiz durumlarda netleştirme sorusu sor
4. Birden fazla eşleşme varsa liste göster, kullanıcıya seçtir
5. Eşleşmeleri doğal dilde açıkla, teknik değil sohbet tarzında

Örnekler:
[Add 5-10 example interactions for each command type]
```

Create functions:
- streamMessage(messages, onChunk) - stream response
- parseWithStructuredOutput(message, schema) - get JSON response
- Both use prompt caching

**src/lib/ai/structured-schemas.ts:**
Define JSON schemas for structured outputs:

```typescript
export const intentSchema = {
  type: 'object',
  properties: {
    intent: {
      type: 'string',
      enum: [
        'add_property',
        'add_customer',
        'search_properties',
        'search_customers',
        'update_status',
        'add_note',
        'request_matches',
        'edit_description',
        'confirm_action',
        'cancel_action',
        'need_clarification',
        'general_chat'
      ]
    },
    confidence: { type: 'string', enum: ['high', 'medium', 'low'] },
    entities: {
      type: 'object',
      properties: {
        propertyType: { type: 'string' },
        rooms: { type: 'string' },
        location: {
          type: 'object',
          properties: {
            city: { type: 'string' },
            district: { type: 'string' }
          }
        },
        price: {
          type: 'object',
          properties: {
            value: { type: 'number' },
            min: { type: 'number' },
            max: { type: 'number' }
          }
        },
        customerName: { type: 'string' },
        status: { type: 'string' },
        propertyReference: { type: 'string' },
        customerReference: { type: 'string' }
      }
    },
    clarificationNeeded: { type: 'string' },
    suggestedActions: { type: 'array', items: { type: 'string' } }
  },
  required: ['intent', 'confidence']
};
```

**src/lib/ai/conversation-context.ts:**
Context window management:
- Keep last 20 messages full
- Summarize older messages (call Claude to summarize if >30 messages)
- Store conversation in Firestore for persistence
- Load recent conversation on chat open
  </action>
  <verify>
- TypeScript compiles
- Claude client can stream a test message
- Structured output returns valid JSON
  </verify>
  <done>
- Claude client with streaming and caching ready
- Structured schemas defined
- Context management for long conversations
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Command Parser and Handlers</name>
  <files>
    src/lib/ai/command-parser.ts
    src/lib/ai/command-handlers.ts
    src/lib/firebase/conversation-service.ts
  </files>
  <action>
**src/lib/ai/command-parser.ts:**
Intent detection and entity extraction:

```typescript
export async function parseCommand(
  userMessage: string,
  conversationHistory: ChatMessage[]
): Promise<ParsedCommand> {
  // Call Claude with structured output
  const result = await parseWithStructuredOutput(
    buildParsingPrompt(userMessage, conversationHistory),
    intentSchema
  );

  // If low confidence, return clarification needed
  if (result.confidence === 'low') {
    return {
      needsClarification: true,
      clarificationQuestion: result.clarificationNeeded ||
        'Anlayamadım. Lütfen daha açık ifade eder misiniz?'
    };
  }

  return {
    needsClarification: false,
    intent: result.intent,
    entities: result.entities,
    suggestedActions: result.suggestedActions
  };
}
```

Handle Turkish-specific parsing:
- Turkish price format: "2M" = 2,000,000, "1.5M" = 1,500,000
- Room format: "3+1", "2+1", "stüdyo"
- Location normalization: handle Turkish chars (ç, ş, ğ, ı, ö, ü)

**src/lib/ai/command-handlers.ts:**
Execute commands based on parsed intent:

```typescript
export async function handleCommand(
  parsed: ParsedCommand,
  context: CommandContext
): Promise<CommandResult> {
  switch (parsed.intent) {
    case 'add_property':
      return handleAddProperty(parsed.entities, context);
    case 'add_customer':
      return handleAddCustomer(parsed.entities, context);
    case 'search_properties':
      return handleSearchProperties(parsed.entities, context);
    case 'update_status':
      return handleUpdateStatus(parsed.entities, context);
    case 'edit_description':
      return handleEditDescription(parsed.entities, context);
    // ... etc
  }
}
```

Each handler:
1. Validates entities are complete
2. If property/customer reference is ambiguous, query Firestore for matches
3. If multiple matches, return clarification with options
4. If single match or new entity, return confirmation prompt
5. On 'confirm_action', execute the actual mutation
6. Return result with embedded card data for display

**src/lib/firebase/conversation-service.ts:**
Firestore persistence for conversations:
- saveMessage(userId, conversationId, message)
- getConversation(userId, conversationId)
- getRecentConversations(userId, limit)
- Store in users/{userId}/conversations/{conversationId}/messages
  </action>
  <verify>
- parseCommand returns structured result
- handleCommand routes to correct handler
- Confirmation flow works (intent detected, confirmation asked)
  </verify>
  <done>
- Command parser extracts intents and entities
- Handlers implement confirmation-first pattern
- Ambiguous references trigger clarification
- Conversations persist in Firestore
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate AI with Chat UI</name>
  <files>
    src/hooks/useChat.ts
    src/components/chat/ChatMessages.tsx
    src/components/chat/InlinePropertyCard.tsx
    src/components/chat/InlineCustomerCard.tsx
  </files>
  <action>
**src/hooks/useChat.ts:**
Replace mock responses with real Claude integration:

```typescript
async function sendMessage(content: string) {
  // Add user message immediately
  addMessage({ role: 'user', content, status: 'sending' });
  setIsLoading(true);

  try {
    // Parse command
    const parsed = await parseCommand(content, messages);

    if (parsed.needsClarification) {
      // AI asks for clarification
      addMessage({
        role: 'assistant',
        content: parsed.clarificationQuestion
      });
      return;
    }

    // Handle the command
    const result = await handleCommand(parsed, {
      userId: user.uid,
      addProperty,
      updateProperty,
      addCustomer,
      // ... other hooks
    });

    // Add AI response with any embedded cards
    addMessage({
      role: 'assistant',
      content: result.message,
      embeddedProperty: result.propertyId,
      embeddedCustomer: result.customerId,
      embeddedMatches: result.matches
    });

    // Save to Firestore
    await saveMessage(user.uid, conversationId, message);

  } catch (error) {
    addMessage({
      role: 'assistant',
      content: 'Bir hata oluştu. Lütfen tekrar deneyin.'
    });
  } finally {
    setIsLoading(false);
  }
}
```

**src/components/chat/InlinePropertyCard.tsx:**
Embedded property card in chat (per user decision):
- Compact card design
- Shows: image/placeholder, title, price, location
- Clickable - opens property detail in new tab/modal
- "Görüntüle" and "Paylaş" buttons

**src/components/chat/InlineCustomerCard.tsx:**
Embedded customer card in chat:
- Shows: name, phone, budget range, urgency
- Clickable - opens customer detail
- "Görüntüle" button

**src/components/chat/ChatMessages.tsx:**
Update to render embedded cards:
- If message.embeddedProperty, render InlinePropertyCard
- If message.embeddedCustomer, render InlineCustomerCard
- If message.embeddedMatches, render match results list

Progress messages (per user decision):
- Show informative loading: "Mülk bilgilerini çıkarıyorum..."
- Different messages for different intents:
  - search: "İstanbul'da villa arıyorum..."
  - add: "Mülk bilgilerini kaydediyorum..."
  - match: "Uygun mülkleri arıyorum..."
  </action>
  <verify>
- Type "3+1 daire Ankara 2M" - AI parses and asks confirmation
- Type "evet" - property created, card shown in chat
- Type "Bodrum villa ara" - search results appear
- Type ambiguous query - AI asks clarifying question
- Conversation persists after page refresh
  </verify>
  <done>
- Chat connected to Claude API
- Commands parsed and executed
- Confirmation flow works
- Embedded cards render in chat
- Conversations persist in Firestore
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. `npm run build` succeeds
2. Open chat, type "3+1 daire Ankara Çankaya 2M TL"
3. AI responds with parsed data and asks "Bu mülkü ekleyeyim mi?"
4. Type "evet" - property created, inline card shown
5. Type "Mehmet adında müşteri ekle" - customer created
6. Type "Bodrum'da villa ara" - search results with inline cards
7. Type "Çankaya" when multiple matches - AI shows list
8. Type "1" to select - action proceeds
9. Refresh page - conversation history restored
10. Check Firestore - messages persisted
</verification>

<success_criteria>
- Natural Turkish commands parsed correctly (AIUI-01, AIUI-02, AIUI-03, AIUI-04)
- AI understands Turkish language (AIUI-05)
- Conversation context maintained (AIUI-06)
- Description editing via chat works (AIUI-08)
- Confirmation before mutations (user decision)
- Clarification for ambiguous commands (user decision)
- Progress messages informative (user decision)
- Embedded cards in chat (user decision)
</success_criteria>

<output>
After completion, create `.planning/phases/02-ai-interface-matching/02-03-SUMMARY.md`
</output>
