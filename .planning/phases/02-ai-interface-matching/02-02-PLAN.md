---
phase: 02-ai-interface-matching
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/chat/ChatFloatingButton.tsx
  - src/components/chat/ChatModal.tsx
  - src/components/chat/ChatMessages.tsx
  - src/components/chat/ChatInput.tsx
  - src/components/chat/ChatBubble.tsx
  - src/components/chat/SuggestionChips.tsx
  - src/components/chat/ChatProvider.tsx
  - src/hooks/useChat.ts
  - src/types/chat.ts
  - src/App.tsx
autonomous: true
requirements:
  - AIUI-05
  - AIUI-06

must_haves:
  truths:
    - "User sees floating chat button on every page"
    - "Clicking button opens chat modal"
    - "Chat modal stays open while navigating pages"
    - "User can type messages and see them in chat"
    - "AI responses appear with loading state"
    - "Suggestion chips appear above input"
    - "Past conversations are visible and scrollable"
  artifacts:
    - path: "src/components/chat/ChatFloatingButton.tsx"
      provides: "WhatsApp-style floating button"
      min_lines: 20
    - path: "src/components/chat/ChatModal.tsx"
      provides: "Modal container with routing persistence"
      min_lines: 50
    - path: "src/components/chat/ChatMessages.tsx"
      provides: "Message list with bubbles"
      min_lines: 40
    - path: "src/components/chat/ChatInput.tsx"
      provides: "Input with voice and attachment buttons"
      min_lines: 60
    - path: "src/hooks/useChat.ts"
      provides: "Chat state management"
      exports: ["useChat"]
  key_links:
    - from: "src/components/chat/ChatModal.tsx"
      to: "src/components/chat/ChatMessages.tsx"
      via: "renders messages"
      pattern: "ChatMessages"
    - from: "src/components/chat/ChatInput.tsx"
      to: "src/hooks/useChat.ts"
      via: "sends messages"
      pattern: "useChat|sendMessage"
---

<objective>
Create the chat UI shell with WhatsApp-style floating button, modal overlay, message bubbles, and input area. This plan focuses purely on UI structure - no AI integration yet.

Purpose: The chat interface is the primary way users interact with the AI assistant. This plan builds the visual foundation that Plan 03 will wire to Claude.
Output: Complete chat UI components ready for AI integration.
</objective>

<execution_context>
@/home/cagr/.claude/get-shit-done/workflows/execute-plan.md
@/home/cagr/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-ai-interface-matching/02-RESEARCH.md
@.planning/phases/02-ai-interface-matching/02-CONTEXT.md

# UI patterns from Phase 1
@src/components/layout/DashboardLayout.tsx
@src/components/ui/button.tsx
@src/components/ui/input.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Chat Types and State Management</name>
  <files>
    src/types/chat.ts
    src/hooks/useChat.ts
    src/components/chat/ChatProvider.tsx
  </files>
  <action>
**src/types/chat.ts:**
```typescript
export interface ChatMessage {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  timestamp: Date;
  status: 'sending' | 'sent' | 'error';
  // For embedded cards
  embeddedProperty?: string;  // propertyId
  embeddedCustomer?: string;  // customerId
  embeddedMatches?: MatchResult[];
}

export interface MatchResult {
  propertyId: string;
  customerId: string;
  score: number;
  explanation: string;
}

export interface Conversation {
  id: string;
  messages: ChatMessage[];
  createdAt: Date;
  updatedAt: Date;
}

export interface ChatState {
  isOpen: boolean;
  isLoading: boolean;
  messages: ChatMessage[];
  conversationId: string | null;
  error: string | null;
}
```

**src/hooks/useChat.ts:**
Create chat state management hook (no AI yet, just local state):
- messages: ChatMessage[]
- isLoading: boolean
- sendMessage(content: string) - adds user message, simulates AI response for now
- clearMessages()
- setIsLoading(boolean)

For now, sendMessage adds user message immediately and after 1s delay adds a mock AI response: "Bu bir test yanıtıdır. AI entegrasyonu Plan 03'te eklenecek."

**src/components/chat/ChatProvider.tsx:**
Context provider that wraps the app:
- Provides chat state via context
- Manages modal open/close state
- State persists across route changes (key feature per user decision)
- Uses React Context for global access
  </action>
  <verify>
- TypeScript compiles without errors
- ChatProvider can wrap App component
- useChat hook returns expected state
  </verify>
  <done>
- Chat types defined
- State management hook working
- Context provider ready for global use
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Chat UI Components</name>
  <files>
    src/components/chat/ChatFloatingButton.tsx
    src/components/chat/ChatModal.tsx
    src/components/chat/ChatMessages.tsx
    src/components/chat/ChatBubble.tsx
    src/components/chat/ChatInput.tsx
    src/components/chat/SuggestionChips.tsx
  </files>
  <action>
**src/components/chat/ChatFloatingButton.tsx:**
- WhatsApp-style circular button, bottom-right corner
- Position: fixed, bottom-6, right-6
- Icon: MessageCircle from lucide-react
- Primary color background (blue-600)
- onClick toggles chat modal open/close
- Visible on ALL pages (positioned outside router)
- Badge showing unread count (optional, start with none)

**src/components/chat/ChatModal.tsx:**
- Fixed position modal overlay (not covering full screen)
- Position: bottom-24, right-6 (above floating button)
- Size: w-96 (384px, ~400px as per user decision), h-[500px]
- Rounded corners, shadow-xl
- Header: "AI Asistan" title + close button (X icon)
- Contains: ChatMessages + SuggestionChips + ChatInput
- Animation: slide up/fade in on open
- z-index higher than sidebar/header

**src/components/chat/ChatMessages.tsx:**
- Scrollable container for messages
- Auto-scroll to bottom on new message
- Map over messages, render ChatBubble for each
- Empty state: "Merhaba! Size nasıl yardımcı olabilirim?"
- Loading indicator when AI is processing

**src/components/chat/ChatBubble.tsx:**
- User messages: right-aligned, colored background (blue-600), white text
- AI messages: left-aligned, gray background (gray-100), dark text
- Timestamp below message (small, muted)
- Status indicator for user messages (sending/sent/error)
- Support for rendering markdown in AI responses (simple version)
- Rounded corners per chat app conventions

**src/components/chat/ChatInput.tsx:**
- Text input with placeholder "Mesaj yazın..."
- Send button (Send icon) - disabled when empty
- Voice input button (Mic icon) - placeholder, non-functional yet
- Attachment button (Paperclip icon) - placeholder, non-functional yet
- Enter key sends message
- Shift+Enter for newline
- Auto-resize textarea (up to 4 lines)

**src/components/chat/SuggestionChips.tsx:**
- Horizontal scrollable row of chips above input
- Fixed suggestions per user decision (Claude's discretion: keep fixed for now):
  - "Mülk ekle"
  - "Müşteri ekle"
  - "Mülk ara"
  - "Eşleşme bul"
  - "İlan yaz"
- Clicking chip inserts text into input
- Small rounded pill buttons
  </action>
  <verify>
- All components render without errors
- Floating button visible on page
- Modal opens/closes correctly
- Messages display in chat bubbles
- Input accepts text and sends
  </verify>
  <done>
- WhatsApp-style floating button working
- Modal opens above button
- Messages render as bubbles (user right, AI left)
- Input with send button functional
- Suggestion chips clickable
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate Chat into App</name>
  <files>
    src/App.tsx
    src/main.tsx
  </files>
  <action>
**src/main.tsx or src/App.tsx:**
- Wrap app with ChatProvider
- ChatProvider should be INSIDE AuthProvider (needs user context)
- ChatProvider should be OUTSIDE Router (modal persists across routes)

**src/App.tsx:**
- Add ChatFloatingButton component at root level
- ChatFloatingButton should be INSIDE ChatProvider but OUTSIDE routes
- Position ensures it's visible on all authenticated pages

Structure:
```tsx
<AuthProvider>
  <ChatProvider>
    <Router>
      <Routes>...</Routes>
      <ChatFloatingButton />  {/* Always visible when logged in */}
      <ChatModal />           {/* Renders when open */}
    </Router>
  </ChatProvider>
</AuthProvider>
```

Only show chat button and modal when user is authenticated (use useAuth to check).
  </action>
  <verify>
- `npm run dev` starts without errors
- Login, navigate to dashboard
- Floating button visible bottom-right
- Click button opens chat modal
- Navigate to /properties - chat stays open
- Navigate to /settings - chat stays open
- Close chat, navigate, reopen - state preserved
- Send test message, see mock response appear
  </verify>
  <done>
- Chat UI integrated into app
- Modal persists across navigation
- Messages work with mock responses
- Ready for AI integration in Plan 03
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. `npm run build` succeeds
2. Login and see floating chat button
3. Click button opens chat modal (~400px wide, above button)
4. Type message, press Enter or click Send
5. User message appears right-aligned in blue
6. Mock AI response appears left-aligned in gray after 1s
7. Navigate to different pages - modal stays open
8. Suggestion chips visible above input
9. Click chip - text appears in input
10. Voice and attachment buttons visible (non-functional)
</verification>

<success_criteria>
- Floating button visible on all authenticated pages
- Chat modal opens/closes correctly
- Modal persists across route changes (user decision)
- Messages display as chat bubbles (user right, AI left)
- Input works with Enter to send
- Suggestion chips insert text into input
- Loading state shows while "AI" processes
- All text in Turkish
</success_criteria>

<output>
After completion, create `.planning/phases/02-ai-interface-matching/02-02-SUMMARY.md`
</output>
